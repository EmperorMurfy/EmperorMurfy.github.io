<!DOCTYPE html>
<html>
<head>
    <title>Fluid ASCII</title>
    <style>
        body {
            background-color: #111;
            color: #eee;
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            overflow: auto;
            touch-action: auto;
        }
        #controls {
            margin-bottom: 10px;
            background: #222;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #444;
            text-align: center;
            font-size: 14px;
        }
        #ascii-container {
            font-size: 10px;
            line-height: 10px;        
            white-space: pre;
            background: #000;
            padding: 20px;
            border: 2px solid #555;
            border-radius: 8px;
            font-weight: bold;
            user-select: none;
            overflow: hidden;
            display: block;
        }
        .w { color: #333; } .f { color: #0af; } .d { color: #06c; } .o { color: #111; }
        .btn {
            background: #444; color: white; border: none; padding: 5px 10px;
            border-radius: 4px; cursor: pointer; margin: 5px;
        }
        .btn:hover { background: #666; }
        input[type=range] { vertical-align: middle; }
    </style>
</head>
<body>
    <div id="controls">
        <button id="accelBtn" class="btn">Enable iPhone Tilt</button>
        <button onclick="sim.reset()" class="btn">Reset Particles</button>
        <br>
        <label>Circle Diameter (chars): <span id="resVal">40</span></label><br>
        <input type="range" id="resSlider" min="20" max="80" step="1" value="40">
        <br>
        <label>Rotation: <span id="rotVal">0</span>°</label><br>
        <input type="range" id="rotSlider" min="-180" max="180" value="0">
        <br>
        <label>Gravity (m/s²) <span id="gravityVal">9.8</span></label><br>
        <input type="range" id="gravitySlider" min="0" max="80" step="0.1" value="9.8">
        <br>
        <label>RAM <span id="memEst">N/A</span></label>
    </div>
    <div id="ascii-container"></div>

<script>
    let DIAMETER = 40;
    let WIDTH = DIAMETER;
    let HEIGHT = DIAMETER;
    const ASPECT_CORRECTION = 1.67;   
    let GRAVITY_STRENGTH = 9.8;
    const DT = 0.025;
    let cellCache = [];
    let container = document.getElementById('ascii-container');

    function initGrid() {
        container.innerHTML = '';
        cellCache = [];
        WIDTH = DIAMETER;
        HEIGHT = DIAMETER;

        for (let y = 0; y < HEIGHT; y++) {
            const rowCache = [];
            for (let x = 0; x < WIDTH; x++) {
                const span = document.createElement('span');
                span.textContent = ' ';
                container.appendChild(span);
                rowCache.push(span);
            }
            if (y < HEIGHT - 1) {
                container.appendChild(document.createElement('br'));
            }
            cellCache.push(rowCache);
        }
    }

    class FluidSim {
        constructor() {
            this.particles = [];
            this.rotation = 0;
            this.radius = 0;
            this.reset();
        }
        reset() {
            this.particles = [];
            this.radius = (DIAMETER / 2) * 0.95;
            const centerX = WIDTH / 2;
            const centerY = HEIGHT / 2;
            const num = Math.floor(WIDTH * HEIGHT * 0.25);
            for (let i = 0; i < num; i++) {
                let angle = Math.random() * Math.PI * 2;
                let r = Math.random() * this.radius * 0.7;
                let x = centerX + r * Math.cos(angle);
                let y = centerY + r * Math.sin(angle);
                this.particles.push({ x, y, vx: 0, vy: 0 });
            }
        }
        update() {
            let rad = this.rotation * (Math.PI / 180);
            let gx = -Math.sin(rad) * GRAVITY_STRENGTH;
            let gy = Math.cos(rad) * GRAVITY_STRENGTH;

            const centerX = WIDTH / 2;
            const centerY = HEIGHT / 2;

            for (let p of this.particles) {
                p.vx += gx * DT;
                p.vy += gy * DT;
                p.x += p.vx * DT;
                p.y += p.vy * DT;

                // Circular boundary with aspect correction
                let dx = p.x - centerX;
                let dy = (p.y - centerY) * ASPECT_CORRECTION;
                let dist = Math.sqrt(dx*dx + dy*dy);
                if (dist > this.radius) {
                    let nx = dx / dist;
                    let ny = dy / dist;
                    let depth = dist - this.radius;
                    p.x -= nx * depth;
                    p.y -= ny * depth / ASPECT_CORRECTION;

                    let dot = p.vx * nx + p.vy * ny;
                    p.vx -= 1.4 * dot * nx;
                    p.vy -= 1.4 * dot * ny;

                    p.vx *= 0.8;
                    p.vy *= 0.8;
                }
            }

            // Particle separation (also aspect-corrected)
            for (let i = 0; i < this.particles.length; i++) {
                let p1 = this.particles[i];
                for (let j = i + 1; j < this.particles.length; j++) {
                    let p2 = this.particles[j];
                    let dx = p1.x - p2.x;
                    let dy = (p1.y - p2.y) * ASPECT_CORRECTION;
                    let d2 = dx*dx + dy*dy;
                    if (d2 < 1.44 && d2 > 0.01) {
                        let d = Math.sqrt(d2);
                        let s = (1.2 - d) / d / 2;
                        p1.x += dx * s;
                        p1.y += dy * s / ASPECT_CORRECTION;
                        p2.x -= dx * s;
                        p2.y -= dy * s / ASPECT_CORRECTION;
                    }
                }
            }
        }
        render() {
            const density = new Int16Array(WIDTH * HEIGHT).fill(0);
            for (let p of this.particles) {
                let ix = Math.floor(p.x);
                let iy = Math.floor(p.y);
                if (ix >= 0 && ix < WIDTH && iy >= 0 && iy < HEIGHT) {
                    density[iy * WIDTH + ix]++;
                }
            }

            const centerX = WIDTH / 2;
            const centerY = HEIGHT / 2;
            const r2 = this.radius * this.radius;

            for (let y = 0; y < HEIGHT; y++) {
                for (let x = 0; x < WIDTH; x++) {
                    let dx = x - centerX;
                    let dy = (y - centerY) * ASPECT_CORRECTION;
                    let isInside = (dx*dx + dy*dy) <= r2;
                    let count = density[y * WIDTH + x];
                    let nC = ' ', nK = 'o';

                    if (isInside) {
                        if (count > 0) {
                            nC = count > 1 ? '@' : 'o';
                            nK = count > 1 ? 'd' : 'f';
                        } else {
                            nC = '-';
                            nK = 'w';
                        }
                    }

                    let span = cellCache[y][x];
                    if (span.textContent !== nC) span.textContent = nC;
                    if (span.className !== nK) span.className = nK;
                }
            }
        }
    }

    initGrid();
    const sim = new FluidSim();
    document.getElementById('gravityVal').innerText = GRAVITY_STRENGTH.toFixed(1);
    updateMemoryEstimate();

    document.getElementById('resSlider').oninput = function() {
        DIAMETER = parseInt(this.value);
        document.getElementById('resVal').innerText = DIAMETER;
        initGrid();
        sim.reset();
        updateMemoryEstimate();
    };

    const rotSlider = document.getElementById('rotSlider');
    rotSlider.oninput = function() {
        sim.rotation = parseFloat(this.value);
        document.getElementById('rotVal').innerText = this.value;
    };

    const gravitySlider = document.getElementById('gravitySlider');
    const gravityVal = document.getElementById('gravityVal');
    gravitySlider.oninput = function() {
        GRAVITY_STRENGTH = parseFloat(this.value);
        gravityVal.innerText = GRAVITY_STRENGTH.toFixed(1);
        updateMemoryEstimate();
    };

    function humanBytes(b) {
        if (b < 1024) return b + ' B';
        if (b < 1024 * 1024) return (b / 1024).toFixed(1) + ' KB';
        return (b / (1024 * 1024)).toFixed(1) + ' MB';
    }

    function updateMemoryEstimate() {
        const numParticles = Math.floor(WIDTH * HEIGHT * 0.25);
        const bytesParticles = numParticles * 32;
        const bytesDensity = WIDTH * HEIGHT * 2;
        const bytesOverhead = numParticles * 24;
        const total = bytesParticles + bytesDensity + bytesOverhead;
        document.getElementById('memEst').innerText = humanBytes(total);
    }

    const accelBtn = document.getElementById('accelBtn');
    accelBtn.onclick = function() {
        if (typeof DeviceOrientationEvent?.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission()
                .then(response => {
                    if (response === 'granted') {
                        window.addEventListener('deviceorientation', handleOrientation);
                        accelBtn.style.display = 'none';
                    }
                }).catch(console.error);
        } else {
            window.addEventListener('deviceorientation', handleOrientation);
            accelBtn.style.display = 'none';
        }
    };

    function handleOrientation(event) {
        let x = event.gamma || 0;
        let y = event.beta || 0;
        let angle = Math.atan2(x, y) * (180 / Math.PI);
        sim.rotation = -angle;
        rotSlider.value = -angle;
        document.getElementById('rotVal').innerText = Math.round(-angle);
    }

    function loop() {
        sim.update();
        sim.render();
        requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
</script>
</body>
</html>
